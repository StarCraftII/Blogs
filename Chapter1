1、数据类型
存储与运算（物理内存与中央处理器）
有限长度的{"0","1"}序列（排成一列的对象，有序的）
集合（由一个或多个确定的元素所构成的整体）
{"0","1"} 是集合
01011001 是序列

有限长度的序列，所能表达的不同序列总数为 M(集合元素数)^N(序列长度)
{"1","2","3"} M=3
当N = 2时，总数=M^N=3^2=9
11、12、13、21、22、23、31、32、33

有限长度的字符集合，其可数（可以记数）长度的序列（即单词），也构成了可数大小的集合
{"1","2","3"} M=3
当N = 2时
{W_0 = Φ，W_1 = {1,2,3}，W_2={11,12,13,21,22,23,31,32,33}}
L = {aa,ab,bb} , Σ = {a,b}，L x Σ = {aaa,aab,aba,abb,bba,bbb}
L x Σ ，对所有左侧集合L的元素的尾部添加右侧集合Σ中的所有元素。
所有可数长度序列的集合，按照序列长度排序（N = 0,1,2,...）,其本身也是可数的。

信息来自于表达与差异，
对于任意字符集，序列的差异使我们能够用序号映射 f(·) 去标注它们之间的不同，而对于差异的解释 g(·) 则创造了序列的语义。

信息量的计算公式：I=log2（1/p），其中p是概率，log2指以二为底的对数。信息量是指从N个相等可能事件中选出一个事件
所需要的信息度量或含量，也就是在辩识N个事件中特定的一个事件的过程中所需要提问"是或否"的最少次数。

1.1、整数类型

W_0 = Φ
W_1 = {"0"<"1"}
W_2 = {"00"<"01"<"10"<"11"}
W_3 = {"000"<"001"<"010"<"011"<"100"<"101"<"110"<"111"}

每一个字符"0"及"1"被称为二进制位（Bit）,每8个Bit构成一个字节（Byte）,也即两个16进制位。

物理内存总是以 8-Bit，也即 Byte 为单位的。

N = 3
111 + 1 = 1000 = 000 溢出
000 - 1 =111 溢出

1.2、浮点数类型

符号：1
指数：8 （偏置 -127）
位数：23

浮点数近似
G（Guard Bit）,被保留的最低位
R（Round Bit）,被舍弃的最高位
S（Sticky Bit）,在R位右侧所有被舍弃的低位之或（OR）

1.3、字符类型

是对Byte的另一种翻译。对一个Byte取数据类型为字符（Character），这个Byte的数值会通过ASCII码表被解释为一个字符。
0x30 '0'	0x39 '9'	0x41 'A'	0x5a 'Z'	0x61 'a'	0x7a 'z'	0x00 NUL

一个char数组构成了一个字符串（String），字符数组在内存中按照下标从小到大，从低地址向高地址储存字符。对于字符串，
内存上的每一Byte被解释为char，直到遇到第一个字符串的终止符 '\0' (0x00)。

1.4、指针类型

数据类型都在物理内存上对应唯一的位置（起始地址），被称为物理地址（Physical Address）。

函数的地址就是其汇编指令的起始地址，

1.5、结构与联合类型

结构（struct）与联合（union）

struct 可以容纳多种其他的基本数据类型。在编译的过程中，对一个struct不同成员（Field）的访问，都会被处理为对
寄存器与内存的访问。在C语音中，其实本质上我们是没有数据类型的，我们所有的只是Byte。

struct按照顺序，将它的成员（内存对齐地）按顺序保存在内存中；union中的成员则共享地址的内存。

对齐（Alignment）,只需考虑该数据类型的内存地址的低位零即可。

union按照Byte最长的数据类型占用内存即可，因为它的成员都是低地址对齐的。
